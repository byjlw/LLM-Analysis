### Customer Segmentation System Implementation
#### Data Preprocessing Module
```javascript
// dataPreprocessing.js
const mongoose = require('mongoose');
const _ = require('lodash');

// Connect to MongoDB
mongoose.connect('mongodb://localhost/customer-segmentation', { useNewUrlParser: true, useUnifiedTopology: true });

// Define the customer schema
const customerSchema = new mongoose.Schema({
  name: String,
  email: String,
  purchases: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Purchase' }]
});

// Define the purchase schema
const purchaseSchema = new mongoose.Schema({
  date: Date,
  amount: Number
});

// Create models
const Customer = mongoose.model('Customer', customerSchema);
const Purchase = mongoose.model('Purchase', purchaseSchema);

// Preprocess customer data
async function preprocessCustomerData() {
  const customers = await Customer.find().populate('purchases');
  const preprocessedData = customers.map(customer => {
    const totalPurchases = customer.purchases.reduce((acc, purchase) => acc + purchase.amount, 0);
    const averagePurchase = totalPurchases / customer.purchases.length;
    return {
      name: customer.name,
      email: customer.email,
      totalPurchases,
      averagePurchase
    };
  });
  return preprocessedData;
}

module.exports = preprocessCustomerData;
```

#### Model Training Module
```javascript
// modelTraining.js
const tf = require('@tensorflow/tfjs');
const _ = require('lodash');

// Train a K-Means clustering model
async function trainModel(preprocessedData) {
  // Convert data to tensors
  const tensorData = tf.tensor2d(preprocessedData.map(customer => [customer.totalPurchases, customer.averagePurchase]));

  // Define the K-Means model
  const model = tf.kmeans(tensorData, 5); // 5 clusters

  // Train the model
  await model.fit();

  // Return the trained model
  return model;
}

module.exports = trainModel;
```

#### Model Inference Module
```javascript
// modelInference.js
const tf = require('@tensorflow/tfjs');

// Use the trained model to segment new customers
async function segmentCustomer(customerData, model) {
  // Convert customer data to tensor
  const tensorData = tf.tensor2d([customerData]);

  // Make predictions
  const prediction = model.predict(tensorData);

  // Return the predicted cluster
  return prediction.arraySync()[0];
}

module.exports = segmentCustomer;
```

#### API for Model Interaction
```javascript
// api.js
const express = require('express');
const app = express();
const preprocessCustomerData = require('./dataPreprocessing');
const trainModel = require('./modelTraining');
const segmentCustomer = require('./modelInference');

// Endpoint for sending new customer data to the model for segmentation
app.post('/segment', async (req, res) => {
  const customerData = req.body;
  const model = await trainModel(await preprocessCustomerData());
  const segment = await segmentCustomer(customerData, model);
  res.json({ segment });
});

// Endpoint for updating the model with new training data
app.post('/update-model', async (req, res) => {
  const newTrainingData = req.body;
  const model = await trainModel(newTrainingData);
  res.json({ message: 'Model updated successfully' });
});

app.listen(3000, () => {
  console.log('Server listening on port 3000');
});
```

#### Testing Strategy
```javascript
// tests.js
const jest = require('jest');
const preprocessCustomerData = require('./dataPreprocessing');
const trainModel = require('./modelTraining');
const segmentCustomer = require('./modelInference');

// Unit tests
describe('preprocessCustomerData', () => {
  it('should return preprocessed customer data', async () => {
    const data = await preprocessCustomerData();
    expect(data).toBeInstanceOf(Array);
  });
});

describe('trainModel', () => {
  it('should return a trained K-Means model', async () => {
    const model = await trainModel(await preprocessCustomerData());
    expect(model).toBeInstanceOf(tf.KMeans);
  });
});

describe('segmentCustomer', () => {
  it('should return the predicted cluster for a new customer', async () => {
    const customerData = { totalPurchases: 100, averagePurchase: 20 };
    const model = await trainModel(await preprocessCustomerData());
    const segment = await segmentCustomer(customerData, model);
    expect(segment).toBeInstanceOf(Number);
  });
});

// Integration tests
describe('API', () => {
  it('should segment a new customer and return the predicted cluster', async () => {
    const customerData = { totalPurchases: 100, averagePurchase: 20 };
    const response = await fetch('http://localhost:3000/segment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(customerData)
    });
    const segment = await response.json();
    expect(segment).toBeInstanceOf(Object);
  });

  it('should update the model with new training data', async () => {
    const newTrainingData = [{ totalPurchases: 200, averagePurchase: 30 }];
    const response = await fetch('http://localhost:3000/update-model', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(newTrainingData)
    });
    const message = await response.json();
    expect(message).toBeInstanceOf(Object);
  });
});
```