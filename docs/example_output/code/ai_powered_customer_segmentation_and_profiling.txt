**data_preprocessing.R**
```r
# Load required libraries
library(RPostgreSQL)
library(dplyr)
library(caret)

# Connect to PostgreSQL database
con <- dbConnect(
  RPostgreSQL::PostgreSQL(),
  host = "localhost",
  port = 5432,
  user = "username",
  password = "password",
  dbname = "database"
)

# Retrieve customer data from PostgreSQL database
customer_data <- dbGetQuery(con, "SELECT * FROM customer_table")

# Clean and preprocess customer data
customer_data <- customer_data %>%
  mutate(
    age = as.numeric(age),
    income = as.numeric(income),
    purchase_history = as.numeric(purchase_history)
  ) %>%
  na.omit() %>%
  scale()

# Close database connection
dbDisconnect(con)

# Save preprocessed data to a CSV file
write.csv(customer_data, "preprocessed_customer_data.csv", row.names = FALSE)
```

**model_training.R**
```r
# Load required libraries
library(cluster)
library(factoextra)

# Load preprocessed customer data
customer_data <- read.csv("preprocessed_customer_data.csv")

# Train K-Means clustering model
set.seed(123)
kmeans_model <- kmeans(customer_data, centers = 5)

# Evaluate model performance using silhouette score
silhouette_score <- silhouette(kmeans_model$cluster, dist(customer_data))
print(silhouette_score)

# Save trained model to an RDS file
saveRDS(kmeans_model, "kmeans_model.rds")
```

**model_deployment.R**
```r
# Load required libraries
library(shiny)
library(plumber)

# Load trained K-Means clustering model
kmeans_model <- readRDS("kmeans_model.rds")

# Define a function to predict customer segments
predict_segment <- function(new_customer_data) {
  new_customer_data <- as.data.frame(new_customer_data)
  predicted_segment <- predict(kmeans_model, new_customer_data)
  return(predicted_segment)
}

# Create a RESTful API to accept new customer data and return predicted segment
api <- plumb("api")
api$POST("/predict", function(req, res) {
  new_customer_data <- req$postBody
  predicted_segment <- predict_segment(new_customer_data)
  res$body <- paste("Predicted segment:", predicted_segment)
  res$status <- 200
})

# Run the API
api$run(port = 8000)
```

**app.R**
```r
# Load required libraries
library(shiny)

# Load trained K-Means clustering model
kmeans_model <- readRDS("kmeans_model.rds")

# Define UI for the Shiny app
ui <- fluidPage(
  titlePanel("Customer Segmentation App"),
  sidebarLayout(
    sidebarPanel(
      numericInput("age", "Age"),
      numericInput("income", "Income"),
      numericInput("purchase_history", "Purchase History"),
      actionButton("predict", "Predict Segment")
    ),
    mainPanel(
      textOutput("predicted_segment")
    )
  )
)

# Define server logic for the Shiny app
server <- function(input, output) {
  predicted_segment <- eventReactive(input$predict, {
    new_customer_data <- data.frame(
      age = input$age,
      income = input$income,
      purchase_history = input$purchase_history
    )
    predicted_segment <- predict(kmeans_model, new_customer_data)
    return(predicted_segment)
  })
  
  output$predicted_segment <- renderText({
    paste("Predicted segment:", predicted_segment())
  })
}

# Run the Shiny app
shinyApp(ui = ui, server = server)
```

**tests.R**
```r
# Load required libraries
library(testthat)

# Load trained K-Means clustering model
kmeans_model <- readRDS("kmeans_model.rds")

# Define test cases for the model
test_predict_segment <- function() {
  new_customer_data <- data.frame(
    age = 25,
    income = 50000,
    purchase_history = 10
  )
  predicted_segment <- predict(kmeans_model, new_customer_data)
  expect_equal(predicted_segment, 1)
}

test_silhouette_score <- function() {
  customer_data <- read.csv("preprocessed_customer_data.csv")
  silhouette_score <- silhouette(kmeans_model$cluster, dist(customer_data))
  expect_greater_than(silhouette_score, 0.5)
}

# Run the tests
test_file("tests.R")
```