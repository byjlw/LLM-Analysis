```python
# Import necessary libraries
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import precision_score, recall_score, f1_score
from sklearn.neighbors import NearestNeighbors
from flask import Flask, jsonify, request
from sklearn.preprocessing import StandardScaler

# Load data from PostgreSQL database
import psycopg2
conn = psycopg2.connect(
    host="localhost",
    database="database",
    user="user",
    password="password"
)
cur = conn.cursor()
cur.execute("SELECT * FROM users")
users = cur.fetchall()
cur.execute("SELECT * FROM ads")
ads = cur.fetchall()
cur.execute("SELECT * FROM user_ad_interactions")
interactions = cur.fetchall()
conn.close()

# Data Preprocessing
users_df = pd.DataFrame(users, columns=['user_id', 'age', 'gender'])
ads_df = pd.DataFrame(ads, columns=['ad_id', 'category'])
interactions_df = pd.DataFrame(interactions, columns=['user_id', 'ad_id', 'rating'])

# Handle missing values
users_df.fillna(users_df.mean(), inplace=True)
ads_df.fillna(ads_df.mean(), inplace=True)
interactions_df.fillna(interactions_df.mean(), inplace=True)

# Normalize data
scaler = StandardScaler()
users_df[['age']] = scaler.fit_transform(users_df[['age']])
ads_df[['category']] = scaler.fit_transform(ads_df[['category']])

# Feature engineering
users_df['gender'] = users_df['gender'].apply(lambda x: 1 if x == 'male' else 0)

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(users_df, interactions_df, test_size=0.2, random_state=42)

# Model Training
# Choose a suitable algorithm (e.g. Collaborative Filtering)
model = NearestNeighbors(n_neighbors=10, algorithm='brute', metric='cosine')
model.fit(X_train)

# Evaluate the model's performance
y_pred = model.kneighbors(X_test, return_distance=False)
precision = precision_score(y_test, y_pred, average='macro')
recall = recall_score(y_test, y_pred, average='macro')
f1 = f1_score(y_test, y_pred, average='macro')
print(f'Precision: {precision}, Recall: {recall}, F1-score: {f1}')

# Model Inference
def get_recommended_ads(user_id, num_recs=10):
    user_data = users_df[users_df['user_id'] == user_id]
    distances, indices = model.kneighbors(user_data, n_neighbors=num_recs)
    recommended_ads = ads_df.iloc[indices[0]]
    return recommended_ads

# Integration
app = Flask(__name__)

@app.route('/get_recommended_ads', methods=['GET'])
def get_recommended_ads_api():
    user_id = request.args.get('user_id')
    num_recs = request.args.get('num_recs', default=10, type=int)
    recommended_ads = get_recommended_ads(int(user_id), num_recs)
    return jsonify({'recommended_ads': recommended_ads.to_dict(orient='records')})

if __name__ == '__main__':
    app.run(debug=True)

# Tests
import unittest
class TestPersonalizedAdvertisingModel(unittest.TestCase):
    def test_get_recommended_ads(self):
        user_id = 1
        num_recs = 10
        recommended_ads = get_recommended_ads(user_id, num_recs)
        self.assertEqual(len(recommended_ads), num_recs)

    def test_model_performance(self):
        self.assertGreater(precision, 0.5)
        self.assertGreater(recall, 0.5)
        self.assertGreater(f1, 0.5)

if __name__ == '__main__':
    unittest.main()
```