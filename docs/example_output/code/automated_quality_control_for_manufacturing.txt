```cpp
// Import necessary libraries
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/ml.hpp>
#include <sqlite3.h>
#include <QtWidgets/QApplication>
#include <QtWidgets/QLabel>
#include <QtWidgets/QPushButton>

// Define constants
const int CAMERA_INDEX = 0;
const int IMAGE_WIDTH = 640;
const int IMAGE_HEIGHT = 480;
const std::string DATABASE_NAME = "product_quality.db";
const std::string TABLE_NAME = "products";

// Function to capture image from industrial camera
cv::Mat captureImage() {
    cv::Mat frame;
    cv::VideoCapture camera(CAMERA_INDEX);
    if (camera.isOpened()) {
        camera >> frame;
        camera.release();
    }
    return frame;
}

// Function to preprocess image
cv::Mat preprocessImage(cv::Mat image) {
    cv::Mat gray;
    cv::cvtColor(image, gray, cv::COLOR_BGR2GRAY);
    cv::GaussianBlur(gray, gray, cv::Size(5, 5), 0);
    return gray;
}

// Function to train CNN for defect detection and classification
cv::Ptr<cv::ml::ANN_MLP> trainCNN(const std::vector<cv::Mat>& images, const std::vector<int>& labels) {
    int numSamples = images.size();
    int numFeatures = images[0].rows * images[0].cols;
    cv::Mat samples(numSamples, numFeatures, CV_32F);
    cv::Mat responses(numSamples, 1, CV_32S);

    for (int i = 0; i < numSamples; i++) {
        images[i].convertTo(samples.row(i), CV_32F);
        responses.at<int>(i, 0) = labels[i];
    }

    cv::Ptr<cv::ml::ANN_MLP> cnn = cv::ml::ANN_MLP::create();
    cnn->setLayerSizes(cv::Mat(4, 1, CV_32S, (int[]) { numFeatures, 128, 64, 1 }));
    cnn->setActivationFunction(cv::ml::ANN_MLP::SIGMOID_SYM, 1, 1);
    cnn->setTermCriteria(cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 1000, 0.001));
    cnn->train(samples, cv::ml::ROW_SAMPLE, responses);

    return cnn;
}

// Function to classify defect using CNN
int classifyDefect(cv::Mat image, cv::Ptr<cv::ml::ANN_MLP> cnn) {
    cv::Mat sample = preprocessImage(image);
    cv::Mat output;
    cnn->predict(sample, output);
    return (int)output.at<float>(0, 0);
}

// Function to make decision for product quality control
void makeDecision(int defectClass, sqlite3* db) {
    if (defectClass == 0) {
        // Accept product
        sqlite3_exec(db, "INSERT INTO products (quality) VALUES ('accept')", NULL, NULL, NULL);
    } else {
        // Reject product
        sqlite3_exec(db, "INSERT INTO products (quality) VALUES ('reject')", NULL, NULL, NULL);
    }
}

// Main function
int main() {
    // Initialize Qt application
    QApplication app(argc, argv);

    // Open SQLite database
    sqlite3* db;
    sqlite3_open(DATABASE_NAME.c_str(), &db);

    // Create table for product quality data
    sqlite3_exec(db, "CREATE TABLE IF NOT EXISTS products (id INTEGER PRIMARY KEY, quality TEXT)", NULL, NULL, NULL);

    // Capture image from industrial camera
    cv::Mat image = captureImage();

    // Preprocess image
    image = preprocessImage(image);

    // Train CNN for defect detection and classification
    std::vector<cv::Mat> images = { /* load images from dataset */ };
    std::vector<int> labels = { /* load labels from dataset */ };
    cv::Ptr<cv::ml::ANN_MLP> cnn = trainCNN(images, labels);

    // Classify defect using CNN
    int defectClass = classifyDefect(image, cnn);

    // Make decision for product quality control
    makeDecision(defectClass, db);

    // Close SQLite database
    sqlite3_close(db);

    // Show result
    QLabel label("Product Quality: ");
    if (defectClass == 0) {
        label.setText("Accept");
    } else {
        label.setText("Reject");
    }
    label.show();

    // Run Qt application
    return app.exec();
}
```