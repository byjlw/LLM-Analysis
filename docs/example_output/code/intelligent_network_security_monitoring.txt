```java
// NetworkTrafficData.java
public class NetworkTrafficData {
    private double[] features;
    private int label;

    public NetworkTrafficData(double[] features, int label) {
        this.features = features;
        this.label = label;
    }

    public double[] getFeatures() {
        return features;
    }

    public int getLabel() {
        return label;
    }
}

// DataPreprocessor.java
import org.deeplearning4j.util.Uitls;

public class DataPreprocessor {
    public static double[][] preprocessData(double[][] data) {
        // Normalize data
        double[][] normalizedData = new double[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data[0].length; j++) {
                normalizedData[i][j] = (data[i][j] - getMin(data)) / (getMax(data) - getMin(data));
            }
        }
        return normalizedData;
    }

    private static double getMin(double[][] data) {
        double min = Double.MAX_VALUE;
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data[0].length; j++) {
                if (data[i][j] < min) {
                    min = data[i][j];
                }
            }
        }
        return min;
    }

    private static double getMax(double[][] data) {
        double max = Double.MIN_VALUE;
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data[0].length; j++) {
                if (data[i][j] > max) {
                    max = data[i][j];
                }
            }
        }
        return max;
    }
}

// ConvolutionalNeuralNetwork.java
import org.deeplearning4j.nn.conf.MultiLayerConfiguration;
import org.deeplearning4j.nn.conf.NeuralNetConfiguration;
import org.deeplearning4j.nn.conf.layers.ConvolutionLayer;
import org.deeplearning4j.nn.conf.layers.DenseLayer;
import org.deeplearning4j.nn.conf.layers.OutputLayer;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.optimize.listeners.ScoreIterationListener;
import org.nd4j.linalg.activations.Activation;
import org.nd4j.linalg.dataset.api.iterator.DataSetIterator;
import org.nd4j.linalg.factory.Nd4j;
import org.nd4j.linalg.learning.config.Nesterovs;
import org.nd4j.linalg.lossfunctions.LossFunctions;

public class ConvolutionalNeuralNetwork {
    public static MultiLayerNetwork createModel() {
        MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder()
                .seed(123)
                .weightInit(org.deeplearning4j.nn.weights.WeightInit.XAVIER)
                .updater(new Nesterovs(0.1))
                .list()
                .layer(0, new ConvolutionLayer.Builder(5, 5)
                        .nIn(1)
                        .stride(1, 1)
                        .nOut(20)
                        .activation(Activation.RELU)
                        .build())
                .layer(1, new DenseLayer.Builder()
                        .nIn(20 * 20 * 20)
                        .nOut(128)
                        .activation(Activation.RELU)
                        .build())
                .layer(2, new OutputLayer.Builder(LossFunctions.LossFunction.NEGATIVELOGLIKELIHOOD)
                        .nIn(128)
                        .nOut(2)
                        .activation(Activation.SOFTMAX)
                        .build())
                .pretrain(false).backprop(true).build();

        MultiLayerNetwork model = new MultiLayerNetwork(conf);
        model.init();
        model.setListeners(new ScoreIterationListener(10));
        return model;
    }
}

// NetworkTrafficDetector.java
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.factory.Nd4j;

public class NetworkTrafficDetector {
    private MultiLayerNetwork model;

    public NetworkTrafficDetector(MultiLayerNetwork model) {
        this.model = model;
    }

    public int detectThreat(double[] features) {
        INDArray input = Nd4j.create(features, 1, features.length);
        INDArray output = model.output(input);
        return output.argMax(1).getInt(0);
    }
}

// NetworkTrafficDataLoader.java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class NetworkTrafficDataLoader {
    public static List<NetworkTrafficData> loadTrainingData(String filePath) {
        List<NetworkTrafficData> data = new ArrayList<>();
        try {
            File file = new File(filePath);
            Scanner scanner = new Scanner(file);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                String[] values = line.split(",");
                double[] features = new double[values.length - 1];
                for (int i = 0; i < features.length; i++) {
                    features[i] = Double.parseDouble(values[i]);
                }
                int label = Integer.parseInt(values[values.length - 1]);
                data.add(new NetworkTrafficData(features, label));
            }
            scanner.close();
        } catch (FileNotFoundException e) {
            System.out.println("File not found");
        }
        return data;
    }
}

// Main.java
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.optimize.listeners.ScoreIterationListener;
import org.nd4j.linalg.dataset.api.iterator.DataSetIterator;
import org.nd4j.linalg.factory.Nd4j;

public class Main {
    public static void main(String[] args) {
        // Load training data
        List<NetworkTrafficData> trainingData = NetworkTrafficDataLoader.loadTrainingData("training_data.csv");

        // Preprocess data
        double[][] features = new double[trainingData.size()][];
        int[] labels = new int[trainingData.size()];
        for (int i = 0; i < trainingData.size(); i++) {
            features[i] = trainingData.get(i).getFeatures();
            labels[i] = trainingData.get(i).getLabel();
        }
        features = DataPreprocessor.preprocessData(features);

        // Create and train model
        MultiLayerNetwork model = ConvolutionalNeuralNetwork.createModel();
        DataSetIterator iterator = new NetworkTrafficDataSetIterator(features, labels, 10);
        model.fit(iterator);

        // Deploy model
        NetworkTrafficDetector detector = new NetworkTrafficDetector(model);

        // Test model
        double[] testFeatures = {1.0, 2.0, 3.0, 4.0, 5.0};
        int predictedLabel = detector.detectThreat(testFeatures);
        System.out.println("Predicted label: " + predictedLabel);
    }
}

// NetworkTrafficDataSetIterator.java
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.nd4j.linalg.dataset.api.iterator.DataSetIterator;
import org.nd4j.linalg.factory.Nd4j;

public class NetworkTrafficDataSetIterator implements DataSetIterator {
    private double[][] features;
    private int[] labels;
    private int batchSize;

    public NetworkTrafficDataSetIterator(double[][] features, int[] labels, int batchSize) {
        this.features = features;
        this.labels = labels;
        this.batchSize = batchSize;
    }

    @Override
    public boolean hasNext() {
        return true;
    }

    @Override
    public org.deeplearning4j.nn.multilayer.MultiLayerNetwork DataSet next() {
        return null;
    }

    @Override
    public boolean reset() {
        return false;
    }

    @Override
    public boolean hasNext() {
        return true;
    }

    @Override
    public org.deeplearning4j.nn.multilayer.MultiLayerNetwork next() {
        return null;
    }

    @Override
    public void remove() {

    }
}
```