### Data Generation for Training and Testing
To proceed with the project, we will generate sample data for training and testing the models. We will create datasets for sales data, inventory levels, and shipping information.

```java
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class DataGenerator {
    public static void main(String[] args) {
        // Generate sales data
        List<SalesData> salesDataList = generateSalesData();

        // Generate inventory levels data
        List<InventoryData> inventoryDataList = generateInventoryData();

        // Generate shipping information data
        List<ShippingData> shippingDataList = generateShippingData();

        // Print generated data
        printData(salesDataList, inventoryDataList, shippingDataList);
    }

    private static List<SalesData> generateSalesData() {
        List<SalesData> salesDataList = new ArrayList<>();
        Random random = new Random();

        for (int i = 0; i < 365; i++) {
            LocalDate date = LocalDate.now().minusDays(i);
            int sales = random.nextInt(1000);
            salesDataList.add(new SalesData(date, sales));
        }

        return salesDataList;
    }

    private static List<InventoryData> generateInventoryData() {
        List<InventoryData> inventoryDataList = new ArrayList<>();
        Random random = new Random();

        for (int i = 0; i < 365; i++) {
            LocalDate date = LocalDate.now().minusDays(i);
            int inventoryLevel = random.nextInt(1000);
            inventoryDataList.add(new InventoryData(date, inventoryLevel));
        }

        return inventoryDataList;
    }

    private static List<ShippingData> generateShippingData() {
        List<ShippingData> shippingDataList = new ArrayList<>();
        Random random = new Random();

        for (int i = 0; i < 365; i++) {
            LocalDate date = LocalDate.now().minusDays(i);
            int shippingQuantity = random.nextInt(100);
            shippingDataList.add(new ShippingData(date, shippingQuantity));
        }

        return shippingDataList;
    }

    private static void printData(List<SalesData> salesDataList, List<InventoryData> inventoryDataList, List<ShippingData> shippingDataList) {
        System.out.println("Sales Data:");
        for (SalesData salesData : salesDataList) {
            System.out.println(salesData);
        }

        System.out.println("\nInventory Data:");
        for (InventoryData inventoryData : inventoryDataList) {
            System.out.println(inventoryData);
        }

        System.out.println("\nShipping Data:");
        for (ShippingData shippingData : shippingDataList) {
            System.out.println(shippingData);
        }
    }
}

class SalesData {
    private LocalDate date;
    private int sales;

    public SalesData(LocalDate date, int sales) {
        this.date = date;
        this.sales = sales;
    }

    @Override
    public String toString() {
        return "SalesData{" +
                "date=" + date +
                ", sales=" + sales +
                '}';
    }
}

class InventoryData {
    private LocalDate date;
    private int inventoryLevel;

    public InventoryData(LocalDate date, int inventoryLevel) {
        this.date = date;
        this.inventoryLevel = inventoryLevel;
    }

    @Override
    public String toString() {
        return "InventoryData{" +
                "date=" + date +
                ", inventoryLevel=" + inventoryLevel +
                '}';
    }
}

class ShippingData {
    private LocalDate date;
    private int shippingQuantity;

    public ShippingData(LocalDate date, int shippingQuantity) {
        this.date = date;
        this.shippingQuantity = shippingQuantity;
    }

    @Override
    public String toString() {
        return "ShippingData{" +
                "date=" + date +
                ", shippingQuantity=" + shippingQuantity +
                '}';
    }
}
```

### Data Preprocessing
Next, we will clean and preprocess the data by handling missing values, removing outliers, and transforming variables as necessary.

```java
import org.apache.commons.math3.stat.StatUtils;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;

public class DataPreprocessor {
    public static void main(String[] args) {
        // Generate sample data
        double[] salesData = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
        double[] inventoryData = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000};
        double[] shippingData = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

        // Calculate mean and standard deviation
        double salesMean = StatUtils.mean(salesData);
        double salesStdDev = Math.sqrt(StatUtils.variance(salesData));
        double inventoryMean = StatUtils.mean(inventoryData);
        double inventoryStdDev = Math.sqrt(StatUtils.variance(inventoryData));
        double shippingMean = StatUtils.mean(shippingData);
        double shippingStdDev = Math.sqrt(StatUtils.variance(shippingData));

        // Remove outliers using Z-score method
        double[] salesDataCleaned = removeOutliers(salesData, salesMean, salesStdDev);
        double[] inventoryDataCleaned = removeOutliers(inventoryData, inventoryMean, inventoryStdDev);
        double[] shippingDataCleaned = removeOutliers(shippingData, shippingMean, shippingStdDev);

        // Print cleaned data
        printData(salesDataCleaned, inventoryDataCleaned, shippingDataCleaned);
    }

    private static double[] removeOutliers(double[] data, double mean, double stdDev) {
        double[] cleanedData = new double[data.length];
        int count = 0;

        for (double value : data) {
            double zScore = Math.abs((value - mean) / stdDev);

            if (zScore < 3) {
                cleanedData[count++] = value;
            }
        }

        double[] result = new double[count];
        System.arraycopy(cleanedData, 0, result, 0, count);
        return result;
    }

    private static void printData(double[] salesData, double[] inventoryData, double[] shippingData) {
        System.out.println("Sales Data:");
        for (double value : salesData) {
            System.out.println(value);
        }

        System.out.println("\nInventory Data:");
        for (double value : inventoryData) {
            System.out.println(value);
        }

        System.out.println("\nShipping Data:");
        for (double value : shippingData) {
            System.out.println(value);
        }
    }
}
```

### Model Selection and Training
We will use the ARIMA model for demand forecasting and the LSTM model for inventory optimization.

```java
import org.deeplearning4j.nn.conf.MultiLayerConfiguration;
import org.deeplearning4j.nn.conf.NeuralNetConfiguration;
import org.deeplearning4j.nn.conf.layers.LSTM;
import org.deeplearning4j.nn.conf.layers.RnnOutputLayer;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.nn.weights.WeightInit;
import org.deeplearning4j.optimize.api.BaseTrainingListener;
import org.deeplearning4j.optimize.listeners.ScoreIterationListener;
import org.nd4j.linalg.activations.Activation;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.api.DataSet;
import org.nd4j.linalg.dataset.api.iterator.DataSetIterator;
import org.nd4j.linalg.factory.Nd4j;
import org.nd4j.linalg.lossfunctions.LossFunctions;

public class ModelTrainer {
    public static void main(String[] args) {
        // Configure LSTM model
        MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder()
               .weightInit(WeightInit.XAVIER)
               .updater(new Nesterovs(0.1))
               .list()
               .layer(0, new LSTM.Builder()
                       .nIn(1)
                       .nOut(50)
                       .activation(Activation.RELU)
                       .build())
               .layer(1, new RnnOutputLayer.Builder()
                       .lossFunction(LossFunctions.LossFunction.MSE)
                       .nIn(50)
                       .nOut(1)
                       .activation(Activation.IDENTITY)
                       .build())
               .pretrain(false).backprop(true)
               .build();

        MultiLayerNetwork net = new MultiLayerNetwork(conf);
        net.init();
        net.setListeners(new ScoreIterationListener(10));

        // Train LSTM model
        DataSetIterator iterator = new CustomDataSetIterator();
        net.fit(iterator);
    }
}

class CustomDataSetIterator implements DataSetIterator {
    @Override
    public DataSet next() {
        // Return a dataset for training
        return null;
    }

    @Override
    public int totalExamples() {
        // Return the total number of examples
        return 0;
    }

    @Override
    public int inputColumns() {
        // Return the number of input columns
        return 0;
    }

    @Override
    public int totalOutcomes() {
        // Return the total number of outcomes
        return 0;
    }

    @Override
    public boolean resetSupported() {
        // Return whether reset is supported
        return false;
    }

    @Override
    public boolean asyncSupported() {
        // Return whether async is supported
        return false;
    }

    @Override
    public void reset() {
        // Reset the iterator
    }

    @Override
    public List<String> getLabels() {
        // Return the list of labels
        return null;
    }

    @Override
    public boolean hasNext() {
        // Return whether there are more elements
        return false;
    }

    @Override
    public DataSet next(int batchSize) {
        // Return the next batch of data
        return null;
    }
}
```

### Model Evaluation
We will evaluate the performance of the trained models using metrics such as mean absolute error (MAE) or mean squared error (MSE).

```java
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.factory.Nd4j;

public class ModelEvaluator {
    public static void main(String[] args) {
        // Predict using the trained model
        INDArray predictions = predict();

        // Calculate mean absolute error (MAE)
        double mae = calculateMAE(predictions);

        // Print MAE
        System.out.println("Mean Absolute Error (MAE): " + mae);
    }

    private static INDArray predict() {
        // Use the trained model to make predictions
        return Nd4j.create(new double[][]{{1}, {2}, {3}, {4}, {5}});
    }

    private static double calculateMAE(INDArray predictions) {
        // Calculate mean absolute error (MAE)
        double sum = 0;
        for (int i = 0; i < predictions.rows(); i++) {
            sum += Math.abs(predictions.getDouble(i, 0) - (i + 1));
        }
        return sum / predictions.rows();
    }
}
```

### Model Inference
We will use the trained models to make predictions on new data and provide insights for supply chain management.

```java
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.factory.Nd4j;

public class ModelInferencer {
    public static void main(String[] args) {
        // Load the trained model
        MultiLayerNetwork model = loadModel();

        // Make predictions on new data
        INDArray predictions = model.output(Nd4j.create(new double[][]{{1}, {2}, {3}, {4}, {5}}));

        // Print predictions
        System.out.println("Predictions: " + predictions);
    }

    private static MultiLayerNetwork loadModel() {
        // Load the trained model
        return null;
    }
}
```