### Inventory Prediction Module
```javascript
// Import required libraries
const mongoose = require('mongoose');
const LSTM = require('lstm-network');
const prophet = require('prophet-js');

// Connect to MongoDB database
mongoose.connect('mongodb://localhost/warehouse', { useNewUrlParser: true, useUnifiedTopology: true });

// Define schema for inventory data
const inventorySchema = new mongoose.Schema({
  date: Date,
  quantity: Number
});

// Create model for inventory data
const Inventory = mongoose.model('Inventory', inventorySchema);

// Define LSTM model for inventory prediction
const lstmModel = new LSTM({
  inputSize: 1,
  outputSize: 1,
  hiddenLayers: [10, 10]
});

// Define Prophet model for inventory prediction
const prophetModel = new prophet({
  growth: 'linear',
  seasonality: 'additive'
});

// Function to predict inventory levels using LSTM
async function predictInventoryLSTM() {
  // Retrieve historical inventory data
  const inventoryData = await Inventory.find().sort({ date: 1 });

  // Prepare input data for LSTM model
  const inputData = inventoryData.map(item => [item.quantity]);

  // Train LSTM model
  lstmModel.train(inputData, {
    iterations: 1000,
    errorThresh: 0.005
  });

  // Use LSTM model to predict future inventory levels
  const predictedInventory = lstmModel.predict(inputData);

  return predictedInventory;
}

// Function to predict inventory levels using Prophet
async function predictInventoryProphet() {
  // Retrieve historical inventory data
  const inventoryData = await Inventory.find().sort({ date: 1 });

  // Prepare input data for Prophet model
  const inputData = inventoryData.map(item => ({ ds: item.date, y: item.quantity }));

  // Train Prophet model
  prophetModel.fit(inputData);

  // Use Prophet model to predict future inventory levels
  const predictedInventory = prophetModel.makeFutureDataFrame(30).map(item => item.yhat);

  return predictedInventory;
}

// Export functions
module.exports = {
  predictInventoryLSTM,
  predictInventoryProphet
};
```

### Warehouse Layout Optimization Module
```javascript
// Import required libraries
const geneticAlgorithm = require('genetic-js');
const simulatedAnnealing = require('simulated-annealing');

// Define warehouse dimensions and inventory data
const warehouseDimensions = {
  length: 100,
  width: 50,
  height: 20
};

const inventoryData = [
  { id: 1, quantity: 10, size: { length: 5, width: 3, height: 2 } },
  { id: 2, quantity: 20, size: { length: 3, width: 2, height: 1 } },
  //...
];

// Define genetic algorithm for warehouse layout optimization
const ga = new geneticAlgorithm({
  populationSize: 100,
  mutationRate: 0.1,
  crossoverRate: 0.5,
  fitnessFunction: (individual) => {
    // Calculate fitness based on warehouse layout efficiency
    const efficiency = calculateEfficiency(individual, warehouseDimensions, inventoryData);
    return efficiency;
  }
});

// Define simulated annealing for warehouse layout optimization
const sa = new simulatedAnnealing({
  initialTemperature: 1000,
  coolingRate: 0.95,
  fitnessFunction: (individual) => {
    // Calculate fitness based on warehouse layout efficiency
    const efficiency = calculateEfficiency(individual, warehouseDimensions, inventoryData);
    return efficiency;
  }
});

// Function to calculate warehouse layout efficiency
function calculateEfficiency(individual, warehouseDimensions, inventoryData) {
  // Calculate efficiency based on storage capacity and retrieval time
  const efficiency = individual.reduce((acc, item) => {
    const storageCapacity = item.size.length * item.size.width * item.size.height;
    const retrievalTime = calculateRetrievalTime(item, warehouseDimensions);
    return acc + storageCapacity / retrievalTime;
  }, 0);

  return efficiency;
}

// Function to calculate retrieval time
function calculateRetrievalTime(item, warehouseDimensions) {
  // Calculate retrieval time based on item location and warehouse dimensions
  const retrievalTime = Math.sqrt(Math.pow(item.location.x - warehouseDimensions.length / 2, 2) + Math.pow(item.location.y - warehouseDimensions.width / 2, 2));
  return retrievalTime;
}

// Export functions
module.exports = {
  optimizeWarehouseLayoutGA: () => ga.evolve(),
  optimizeWarehouseLayoutSA: () => sa.optimize()
};
```

### Shipping Route Optimization Module
```javascript
// Import required libraries
const dijkstra = require('dijkstra');
const aStar = require('a-star');

// Define warehouse location and delivery locations
const warehouseLocation = { x: 0, y: 0 };
const deliveryLocations = [
  { id: 1, location: { x: 10, y: 10 } },
  { id: 2, location: { x: 20, y: 20 } },
  //...
];

// Define graph for Dijkstra's algorithm
const graph = {};
deliveryLocations.forEach((location) => {
  graph[location.id] = {};
  deliveryLocations.forEach((otherLocation) => {
    if (location.id!== otherLocation.id) {
      graph[location.id][otherLocation.id] = calculateDistance(location.location, otherLocation.location);
    }
  });
});

// Define heuristic function for A\* algorithm
function heuristic(location) {
  // Calculate heuristic based on distance from warehouse location
  return calculateDistance(location, warehouseLocation);
}

// Function to calculate distance between two locations
function calculateDistance(location1, location2) {
  // Calculate distance based on Euclidean distance
  return Math.sqrt(Math.pow(location1.x - location2.x, 2) + Math.pow(location1.y - location2.y, 2));
}

// Function to optimize shipping routes using Dijkstra's algorithm
function optimizeShippingRoutesDijkstra() {
  // Find shortest path from warehouse location to each delivery location
  const shortestPaths = {};
  deliveryLocations.forEach((location) => {
    const shortestPath = dijkstra.findShortestPath(graph, warehouseLocation, location.id);
    shortestPaths[location.id] = shortestPath;
  });

  return shortestPaths;
}

// Function to optimize shipping routes using A\* algorithm
function optimizeShippingRoutesAStar() {
  // Find shortest path from warehouse location to each delivery location
  const shortestPaths = {};
  deliveryLocations.forEach((location) => {
    const shortestPath = aStar.findShortestPath(graph, warehouseLocation, location.id, heuristic);
    shortestPaths[location.id] = shortestPath;
  });

  return shortestPaths;
}

// Export functions
module.exports = {
  optimizeShippingRoutesDijkstra,
  optimizeShippingRoutesAStar
};
```

### Integration with Existing Warehouse Management System
```javascript
// Import required libraries
const express = require('express');
const app = express();

// Import AI/ML modules
const inventoryPrediction = require('./inventory-prediction');
const warehouseLayoutOptimization = require('./warehouse-layout-optimization');
const shippingRouteOptimization = require('./shipping-route-optimization');

// Define API endpoints
app.get('/predict-inventory', async (req, res) => {
  const predictedInventory = await inventoryPrediction.predictInventoryLSTM();
  res.json(predictedInventory);
});

app.get('/optimize-warehouse-layout', async (req, res) => {
  const optimizedLayout = await warehouseLayoutOptimization.optimizeWarehouseLayoutGA();
  res.json(optimizedLayout);
});

app.get('/optimize-shipping-routes', async (req, res) => {
  const optimizedRoutes = await shippingRouteOptimization.optimizeShippingRoutesDijkstra();
  res.json(optimizedRoutes);
});

// Start server
app.listen(3000, () => {
  console.log('Server started on port 3000');
});
```

### Testing
```javascript
// Import required libraries
const jest = require('jest');
const inventoryPrediction = require('./inventory-prediction');
const warehouseLayoutOptimization = require('./warehouse-layout-optimization');
const shippingRouteOptimization = require('./shipping-route-optimization');

// Define test cases
describe('Inventory Prediction', () => {
  it('should predict inventory levels', async () => {
    const predictedInventory = await inventoryPrediction.predictInventoryLSTM();
    expect(predictedInventory).toBeInstanceOf(Array);
  });
});

describe('Warehouse Layout Optimization', () => {
  it('should optimize warehouse layout', async () => {
    const optimizedLayout = await warehouseLayoutOptimization.optimizeWarehouseLayoutGA();
    expect(optimizedLayout).toBeInstanceOf(Array);
  });
});

describe('Shipping Route Optimization', () => {
  it('should optimize shipping routes', async () => {
    const optimizedRoutes = await shippingRouteOptimization.optimizeShippingRoutesDijkstra();
    expect(optimizedRoutes).toBeInstanceOf(Object);
  });
});

// Run tests
jest.run();
```