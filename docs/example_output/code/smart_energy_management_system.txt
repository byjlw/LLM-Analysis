```cpp
// EnergyConsumptionPredictionModel.h
#ifndef ENERGY_CONSUMPTION_PREDICTION_MODEL_H
#define ENERGY_CONSUMPTION_PREDICTION_MODEL_H

#include <tensorflow/lite/c/c_api.h>
#include <tensorflow/lite/c/c_api_types.h>

class EnergyConsumptionPredictionModel {
public:
    EnergyConsumptionPredictionModel(const char* model_path);
    ~EnergyConsumptionPredictionModel();

    float predict(float time_of_day, float day_of_week, float season, float current_energy_consumption);

private:
    TfLiteInterpreter* interpreter_;
    TfLiteTensor* input_tensor_;
    TfLiteTensor* output_tensor_;
};

#endif  // ENERGY_CONSUMPTION_PREDICTION_MODEL_H
```

```cpp
// EnergyConsumptionPredictionModel.cpp
#include "EnergyConsumptionPredictionModel.h"

EnergyConsumptionPredictionModel::EnergyConsumptionPredictionModel(const char* model_path) {
    // Load the TensorFlow Lite model
    TfLiteModel* model = TfLiteModelCreateFromFile(model_path);
    TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();
    interpreter_ = TfLiteNewInterpreter(model, options);
    TfLiteInterpreterAllocateTensors(interpreter_);

    // Get the input and output tensors
    int num_inputs = TfLiteInterpreterGetNumberOfInputs(interpreter_);
    int num_outputs = TfLiteInterpreterGetNumberOfOutputs(interpreter_);
    input_tensor_ = TfLiteInterpreterGetInputTensor(interpreter_, 0);
    output_tensor_ = TfLiteInterpreterGetOutputTensor(interpreter_, 0);
}

EnergyConsumptionPredictionModel::~EnergyConsumptionPredictionModel() {
    // Release the TensorFlow Lite interpreter and model
    TfLiteInterpreterDelete(interpreter_);
}

float EnergyConsumptionPredictionModel::predict(float time_of_day, float day_of_week, float season, float current_energy_consumption) {
    // Create a tensor for the input data
    TfLiteTensor* input_data = TfLiteTensorCreate(NULL, TfLiteTypeFloat32, 1, 4);
    float* input_data_ptr = TfLiteTensorData(input_data);
    input_data_ptr[0] = time_of_day;
    input_data_ptr[1] = day_of_week;
    input_data_ptr[2] = season;
    input_data_ptr[3] = current_energy_consumption;

    // Copy the input data to the interpreter's input tensor
    TfLiteTensorCopy(input_data, input_tensor_);

    // Run the inference
    TfLiteInterpreterInvoke(interpreter_);

    // Get the predicted energy consumption from the output tensor
    float* output_data_ptr = TfLiteTensorData(output_tensor_);
    float predicted_energy_consumption = output_data_ptr[0];

    // Release the input data tensor
    TfLiteTensorDelete(input_data);

    return predicted_energy_consumption;
}
```

```cpp
// AnomalyDetectionModel.h
#ifndef ANOMALY_DETECTION_MODEL_H
#define ANOMALY_DETECTION_MODEL_H

#include <vector>
#include <cmath>

class AnomalyDetectionModel {
public:
    AnomalyDetectionModel(float threshold);
    ~AnomalyDetectionModel();

    bool detectAnomaly(const std::vector<float>& energy_consumption_pattern);

private:
    float threshold_;
};

#endif  // ANOMALY_DETECTION_MODEL_H
```

```cpp
// AnomalyDetectionModel.cpp
#include "AnomalyDetectionModel.h"

AnomalyDetectionModel::AnomalyDetectionModel(float threshold) : threshold_(threshold) {}

AnomalyDetectionModel::~AnomalyDetectionModel() {}

bool AnomalyDetectionModel::detectAnomaly(const std::vector<float>& energy_consumption_pattern) {
    // Calculate the mean and standard deviation of the energy consumption pattern
    float mean = 0.0f;
    float sum = 0.0f;
    for (float value : energy_consumption_pattern) {
        sum += value;
    }
    mean = sum / energy_consumption_pattern.size();

    float std_dev = 0.0f;
    for (float value : energy_consumption_pattern) {
        std_dev += pow(value - mean, 2);
    }
    std_dev = sqrt(std_dev / energy_consumption_pattern.size());

    // Check if the current energy consumption is within the threshold of the mean
    float current_energy_consumption = energy_consumption_pattern.back();
    if (abs(current_energy_consumption - mean) > threshold_ * std_dev) {
        return true;  // Anomaly detected
    } else {
        return false;  // No anomaly detected
    }
}
```

```cpp
// OptimizationAlgorithm.h
#ifndef OPTIMIZATION_ALGORITHM_H
#define OPTIMIZATION_ALGORITHM_H

#include <vector>
#include <limits>

class OptimizationAlgorithm {
public:
    OptimizationAlgorithm(float predicted_energy_consumption, bool anomaly_detected);
    ~OptimizationAlgorithm();

    std::vector<float> optimizeEnergyConsumption();

private:
    float predicted_energy_consumption_;
    bool anomaly_detected_;
};

#endif  // OPTIMIZATION_ALGORITHM_H
```

```cpp
// OptimizationAlgorithm.cpp
#include "OptimizationAlgorithm.h"

OptimizationAlgorithm::OptimizationAlgorithm(float predicted_energy_consumption, bool anomaly_detected)
    : predicted_energy_consumption_(predicted_energy_consumption), anomaly_detected_(anomaly_detected) {}

OptimizationAlgorithm::~OptimizationAlgorithm() {}

std::vector<float> OptimizationAlgorithm::optimizeEnergyConsumption() {
    // Simple linear programming optimization algorithm
    // Reduce energy consumption by 10% if anomaly is detected
    if (anomaly_detected_) {
        predicted_energy_consumption_ *= 0.9f;
    }

    // Create an optimized energy consumption plan
    std::vector<float> optimized_energy_consumption_plan;
    for (int i = 0; i < 24; i++) {  // Assuming 24 hours in a day
        optimized_energy_consumption_plan.push_back(predicted_energy_consumption_ / 24.0f);
    }

    return optimized_energy_consumption_plan;
}
```

```cpp
// main.cpp
#include "EnergyConsumptionPredictionModel.h"
#include "AnomalyDetectionModel.h"
#include "OptimizationAlgorithm.h"

int main() {
    // Create instances of the models and algorithm
    EnergyConsumptionPredictionModel prediction_model("energy_consumption_model.tflite");
    AnomalyDetectionModel anomaly_detection_model(2.0f);  // Threshold of 2 standard deviations
    OptimizationAlgorithm optimization_algorithm(0.0f, false);  // Initialize with dummy values

    // Simulate energy consumption data
    std::vector<float> energy_consumption_pattern = {10.0f, 12.0f, 15.0f, 18.0f, 20.0f};

    // Predict energy consumption
    float predicted_energy_consumption = prediction_model.predict(12.0f, 3.0f, 2.0f, 15.0f);
    std::cout << "Predicted energy consumption: " << predicted_energy_consumption << std::endl;

    // Detect anomalies
    bool anomaly_detected = anomaly_detection_model.detectAnomaly(energy_consumption_pattern);
    std::cout << "Anomaly detected: " << (anomaly_detected? "Yes" : "No") << std::endl;

    // Optimize energy consumption
    optimization_algorithm = OptimizationAlgorithm(predicted_energy_consumption, anomaly_detected);
    std::vector<float> optimized_energy_consumption_plan = optimization_algorithm.optimizeEnergyConsumption();
    std::cout << "Optimized energy consumption plan: ";
    for (float value : optimized_energy_consumption_plan) {
        std::cout << value << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

```cpp
// test_EnergyConsumptionPredictionModel.cpp
#include "EnergyConsumptionPredictionModel.h"
#include <gtest/gtest.h>

TEST(EnergyConsumptionPredictionModelTest, PredictEnergyConsumption) {
    EnergyConsumptionPredictionModel model("energy_consumption_model.tflite");
    float predicted_energy_consumption = model.predict(12.0f, 3.0f, 2.0f, 15.0f);
    EXPECT_GT(predicted_energy_consumption, 0.0f);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

```cpp
// test_AnomalyDetectionModel.cpp
#include "AnomalyDetectionModel.h"
#include <gtest/gtest.h>

TEST(AnomalyDetectionModelTest, DetectAnomaly) {
    AnomalyDetectionModel model(2.0f);
    std::vector<float> energy_consumption_pattern = {10.0f, 12.0f, 15.0f, 18.0f, 20.0f};
    bool anomaly_detected = model.detectAnomaly(energy_consumption_pattern);
    EXPECT_FALSE(anomaly_detected);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

```cpp
// test_OptimizationAlgorithm.cpp
#include "OptimizationAlgorithm.h"
#include <gtest/gtest.h>

TEST(OptimizationAlgorithmTest, OptimizeEnergyConsumption) {
    OptimizationAlgorithm algorithm(10.0f, false);
    std::vector<float> optimized_energy_consumption_plan = algorithm.optimizeEnergyConsumption();
    EXPECT_GT(optimized_energy_consumption_plan.size(), 0);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```