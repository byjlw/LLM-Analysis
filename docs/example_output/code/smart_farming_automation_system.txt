```cpp
// smart_farming_automation_system.cpp

#include <iostream>
#include <vector>
#include <cmath>
#include <random>
#include <Eigen/Dense>

// Define a struct to represent the data from IoT sensors
struct SensorData {
    double temperature;
    double humidity;
    double soilMoisture;
};

// Define a struct to represent the output of the machine learning model
struct ModelOutput {
    double predictedCropYield;
    double issueDetection;
};

// Function to preprocess and normalize incoming data from IoT sensors
SensorData preprocessData(const SensorData& data) {
    // Normalize temperature between 0 and 1
    double normalizedTemperature = (data.temperature - 20) / (40 - 20);
    // Normalize humidity between 0 and 1
    double normalizedHumidity = (data.humidity - 30) / (80 - 30);
    // Normalize soil moisture between 0 and 1
    double normalizedSoilMoisture = (data.soilMoisture - 10) / (50 - 10);

    return {normalizedTemperature, normalizedHumidity, normalizedSoilMoisture};
}

// Function to train a machine learning model using local data
Eigen::MatrixXd trainModel(const std::vector<SensorData>& trainingData, const std::vector<ModelOutput>& trainingOutputs) {
    // Create a matrix to store the input features
    Eigen::MatrixXd inputFeatures(trainingData.size(), 3);
    // Create a matrix to store the output features
    Eigen::MatrixXd outputFeatures(trainingData.size(), 2);

    // Populate the input features matrix
    for (int i = 0; i < trainingData.size(); i++) {
        inputFeatures(i, 0) = trainingData[i].temperature;
        inputFeatures(i, 1) = trainingData[i].humidity;
        inputFeatures(i, 2) = trainingData[i].soilMoisture;
    }

    // Populate the output features matrix
    for (int i = 0; i < trainingData.size(); i++) {
        outputFeatures(i, 0) = trainingOutputs[i].predictedCropYield;
        outputFeatures(i, 1) = trainingOutputs[i].issueDetection;
    }

    // Train a regression-based model using the input and output features
    Eigen::MatrixXd modelCoefficients = (inputFeatures.transpose() * inputFeatures).inverse() * inputFeatures.transpose() * outputFeatures;

    return modelCoefficients;
}

// Function to make predictions using the trained model
ModelOutput makePrediction(const SensorData& data, const Eigen::MatrixXd& modelCoefficients) {
    // Preprocess and normalize the input data
    SensorData normalizedData = preprocessData(data);

    // Make a prediction using the trained model
    double predictedCropYield = modelCoefficients(0, 0) * normalizedData.temperature + modelCoefficients(1, 0) * normalizedData.humidity + modelCoefficients(2, 0) * normalizedData.soilMoisture;
    double issueDetection = modelCoefficients(0, 1) * normalizedData.temperature + modelCoefficients(1, 1) * normalizedData.humidity + modelCoefficients(2, 1) * normalizedData.soilMoisture;

    return {predictedCropYield, issueDetection};
}

// Test function to evaluate the model's performance
void testModel(const Eigen::MatrixXd& modelCoefficients, const std::vector<SensorData>& testingData, const std::vector<ModelOutput>& testingOutputs) {
    // Evaluate the model's performance using metrics such as accuracy, precision, and recall
    double accuracy = 0;
    double precision = 0;
    double recall = 0;

    for (int i = 0; i < testingData.size(); i++) {
        ModelOutput prediction = makePrediction(testingData[i], modelCoefficients);
        accuracy += std::abs(prediction.predictedCropYield - testingOutputs[i].predictedCropYield);
        precision += std::abs(prediction.issueDetection - testingOutputs[i].issueDetection);
        recall += std::abs(prediction.issueDetection - testingOutputs[i].issueDetection);
    }

    std::cout << "Accuracy: " << accuracy / testingData.size() << std::endl;
    std::cout << "Precision: " << precision / testingData.size() << std::endl;
    std::cout << "Recall: " << recall / testingData.size() << std::endl;
}

int main() {
    // Generate some sample training data
    std::vector<SensorData> trainingData = {
        {25, 60, 20},
        {30, 70, 30},
        {20, 50, 15},
        {28, 65, 25},
        {32, 75, 35}
    };

    std::vector<ModelOutput> trainingOutputs = {
        {10, 0.5},
        {12, 0.6},
        {8, 0.4},
        {11, 0.55},
        {13, 0.65}
    };

    // Train the model
    Eigen::MatrixXd modelCoefficients = trainModel(trainingData, trainingOutputs);

    // Generate some sample testing data
    std::vector<SensorData> testingData = {
        {26, 61, 21},
        {31, 71, 31},
        {21, 51, 16},
        {29, 66, 26},
        {33, 76, 36}
    };

    std::vector<ModelOutput> testingOutputs = {
        {10.5, 0.55},
        {12.5, 0.65},
        {8.5, 0.45},
        {11.5, 0.6},
        {13.5, 0.7}
    };

    // Test the model
    testModel(modelCoefficients, testingData, testingOutputs);

    // Make a prediction using the trained model
    SensorData inputData = {27, 62, 22};
    ModelOutput prediction = makePrediction(inputData, modelCoefficients);
    std::cout << "Predicted crop yield: " << prediction.predictedCropYield << std::endl;
    std::cout << "Issue detection: " << prediction.issueDetection << std::endl;

    return 0;
}
```