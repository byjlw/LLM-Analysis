```cpp
// SensorDataCollector.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>

class SensorDataCollector {
public:
    std::vector<std::string> collectData() {
        // Simulate collecting data from IoT sensors
        std::vector<std::string> data = {"temperature:20", "lighting:50", "device_usage:30"};
        return data;
    }
};

// DataPreprocessor.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>

class DataPreprocessor {
public:
    std::vector<std::vector<double>> preprocessData(const std::vector<std::string>& data) {
        // Preprocess the collected data
        std::vector<std::vector<double>> preprocessedData;
        for (const auto& d : data) {
            std::vector<double> features;
            // Extract features from the data
            size_t pos = d.find(":");
            if (pos != std::string::npos) {
                features.push_back(std::stod(d.substr(pos + 1)));
            }
            preprocessedData.push_back(features);
        }
        return preprocessedData;
    }
};

// MachineLearningModel.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include "DecisionTree.h"

class MachineLearningModel {
public:
    DecisionTree* trainModel(const std::vector<std::vector<double>>& preprocessedData) {
        // Train a decision tree model on the preprocessed data
        DecisionTree* model = new DecisionTree();
        model->train(preprocessedData);
        return model;
    }
};

// PredictionEngine.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include "DecisionTree.h"

class PredictionEngine {
public:
    std::vector<double> makePrediction(DecisionTree* model, const std::vector<double>& inputData) {
        // Use the trained model to make predictions
        std::vector<double> prediction = model->predict(inputData);
        return prediction;
    }
};

// DecisionTree.h
#ifndef DECISIONTREE_H
#define DECISIONTREE_H

#include <iostream>
#include <vector>
#include <string>
#include <cstdint>

class DecisionTree {
public:
    void train(const std::vector<std::vector<double>>& data);
    std::vector<double> predict(const std::vector<double>& inputData);
};

#endif  // DECISIONTREE_H

// DecisionTree.cpp
#include "DecisionTree.h"

void DecisionTree::train(const std::vector<std::vector<double>>& data) {
    // Train the decision tree model
    // For simplicity, this example uses a basic decision tree algorithm
    // In a real-world implementation, you would use a more robust algorithm
    // such as ID3 or C4.5
    if (data.size() > 0) {
        // Create the root node
        // ...
    }
}

std::vector<double> DecisionTree::predict(const std::vector<double>& inputData) {
    // Make a prediction using the trained decision tree model
    // For simplicity, this example returns a fixed prediction
    // In a real-world implementation, you would use the trained model to make a prediction
    std::vector<double> prediction = {1.0, 2.0, 3.0};
    return prediction;
}

// main.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include "SensorDataCollector.h"
#include "DataPreprocessor.h"
#include "MachineLearningModel.h"
#include "PredictionEngine.h"
#include "DecisionTree.h"

int main() {
    // Collect data from IoT sensors
    SensorDataCollector collector;
    std::vector<std::string> data = collector.collectData();

    // Preprocess the collected data
    DataPreprocessor preprocessor;
    std::vector<std::vector<double>> preprocessedData = preprocessor.preprocessData(data);

    // Train a machine learning model on the preprocessed data
    MachineLearningModel model;
    DecisionTree* trainedModel = model.trainModel(preprocessedData);

    // Use the trained model to make predictions
    PredictionEngine engine;
    std::vector<double> prediction = engine.makePrediction(trainedModel, {1.0, 2.0, 3.0});

    // Print the prediction
    std::cout << "Prediction: ";
    for (double p : prediction) {
        std::cout << p << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

```cpp
// test_SensorDataCollector.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include "SensorDataCollector.h"
#include "gtest/gtest.h"

TEST(SensorDataCollectorTest, collectData) {
    SensorDataCollector collector;
    std::vector<std::string> data = collector.collectData();
    EXPECT_EQ(data.size(), 3);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

```cpp
// test_DataPreprocessor.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include "DataPreprocessor.h"
#include "gtest/gtest.h"

TEST(DataPreprocessorTest, preprocessData) {
    DataPreprocessor preprocessor;
    std::vector<std::string> data = {"temperature:20", "lighting:50", "device_usage:30"};
    std::vector<std::vector<double>> preprocessedData = preprocessor.preprocessData(data);
    EXPECT_EQ(preprocessedData.size(), 3);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

```cpp
// test_MachineLearningModel.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include "MachineLearningModel.h"
#include "DecisionTree.h"
#include "gtest/gtest.h"

TEST(MachineLearningModelTest, trainModel) {
    MachineLearningModel model;
    std::vector<std::vector<double>> data = {{1.0}, {2.0}, {3.0}};
    DecisionTree* trainedModel = model.trainModel(data);
    EXPECT_NE(trainedModel, nullptr);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

```cpp
// test_PredictionEngine.cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include "PredictionEngine.h"
#include "DecisionTree.h"
#include "gtest/gtest.h"

TEST(PredictionEngineTest, makePrediction) {
    PredictionEngine engine;
    DecisionTree* model = new DecisionTree();
    std::vector<double> inputData = {1.0, 2.0, 3.0};
    std::vector<double> prediction = engine.makePrediction(model, inputData);
    EXPECT_EQ(prediction.size(), 3);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```