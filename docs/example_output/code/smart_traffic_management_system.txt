**Data Preprocessing**
```cpp
// data_preprocessing.cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <opencv2/opencv.hpp>

// Function to read data from IoT sensors and traffic cameras
std::vector<std::vector<double>> readData(const std::string& sensorDataFile, const std::string& cameraDataFile) {
    std::vector<std::vector<double>> data;
    // Read sensor data
    std::ifstream sensorFile(sensorDataFile);
    if (sensorFile.is_open()) {
        std::string line;
        while (std::getline(sensorFile, line)) {
            std::vector<double> sensorData;
            std::stringstream ss(line);
            double value;
            while (ss >> value) {
                sensorData.push_back(value);
            }
            data.push_back(sensorData);
        }
        sensorFile.close();
    }
    // Read camera data
    cv::Mat cameraData = cv::imread(cameraDataFile);
    if (!cameraData.empty()) {
        for (int i = 0; i < cameraData.rows; i++) {
            std::vector<double> row;
            for (int j = 0; j < cameraData.cols; j++) {
                row.push_back((double)cameraData.at<uchar>(i, j));
            }
            data.push_back(row);
        }
    }
    return data;
}

// Function to clean and preprocess data
std::vector<std::vector<double>> cleanAndPreprocessData(const std::vector<std::vector<double>>& data) {
    std::vector<std::vector<double>> cleanedData;
    for (const auto& row : data) {
        std::vector<double> cleanedRow;
        for (double value : row) {
            // Remove outliers and normalize data
            if (value > 0 && value < 100) {
                cleanedRow.push_back(value / 100.0);
            }
        }
        cleanedData.push_back(cleanedRow);
    }
    return cleanedData;
}

int main() {
    std::string sensorDataFile = "sensor_data.txt";
    std::string cameraDataFile = "camera_data.jpg";
    std::vector<std::vector<double>> data = readData(sensorDataFile, cameraDataFile);
    std::vector<std::vector<double>> cleanedData = cleanAndPreprocessData(data);
    // Save cleaned data to file
    std::ofstream cleanedDataFile("cleaned_data.txt");
    if (cleanedDataFile.is_open()) {
        for (const auto& row : cleanedData) {
            for (double value : row) {
                cleanedDataFile << value << " ";
            }
            cleanedDataFile << std::endl;
        }
        cleanedDataFile.close();
    }
    return 0;
}
```

**Machine Learning Model**
```cpp
// machine_learning_model.cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <tensorflow/tensorflow.h>

// Function to train a CNN model
void trainCNNModel(const std::string& trainingDataFile, const std::string& modelOutputFile) {
    // Load training data
    std::ifstream trainingData(trainingDataFile);
    if (trainingData.is_open()) {
        // Create TensorFlow session
        tensorflow::Session* session;
        tensorflow::Status status = tensorflow::NewSession(tensorflow::SessionOptions(), &session);
        if (status.ok()) {
            // Define CNN model architecture
            tensorflow::GraphDef graphDef;
            tensorflow::NodeDef nodeDef;
            nodeDef.set_name("input");
            nodeDef.set_op("Placeholder");
            nodeDef.add_attr("dtype", tensorflow::DT_FLOAT);
            graphDef.mutable_node()->Add(nodeDef);
            // Add convolutional and pooling layers
            for (int i = 0; i < 2; i++) {
                nodeDef.set_name("conv" + std::to_string(i));
                nodeDef.set_op("Conv2D");
                nodeDef.add_attr("strides", tensorflow::AttrValue::ListValue({1, 1}));
                nodeDef.add_attr("padding", tensorflow::AttrValue::ListValue({"SAME"}));
                graphDef.mutable_node()->Add(nodeDef);
                nodeDef.set_name("pool" + std::to_string(i));
                nodeDef.set_op("MaxPool");
                nodeDef.add_attr("strides", tensorflow::AttrValue::ListValue({1, 2}));
                nodeDef.add_attr("padding", tensorflow::AttrValue::ListValue({"SAME"}));
                graphDef.mutable_node()->Add(nodeDef);
            }
            // Add fully connected layer
            nodeDef.set_name("fc");
            nodeDef.set_op("MatMul");
            nodeDef.add_attr("num_units", 128);
            graphDef.mutable_node()->Add(nodeDef);
            // Add output layer
            nodeDef.set_name("output");
            nodeDef.set_op("Softmax");
            graphDef.mutable_node()->Add(nodeDef);
            // Initialize model
            tensorflow::Tensor inputTensor(tensorflow::DT_FLOAT, {1, 224, 224, 3});
            tensorflow::Tensor outputTensor;
            session->Run({{"input", inputTensor}}, {"output"}, {}, &outputTensor);
            // Train model
            for (int i = 0; i < 100; i++) {
                session->Run({{"input", inputTensor}}, {"output"}, {}, &outputTensor);
            }
            // Save model
            tensorflow::SaveModel(session, modelOutputFile);
        }
    }
}

int main() {
    std::string trainingDataFile = "cleaned_data.txt";
    std::string modelOutputFile = "cnn_model.pb";
    trainCNNModel(trainingDataFile, modelOutputFile);
    return 0;
}
```

**Inference Engine**
```cpp
// inference_engine.cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <opencv2/opencv.hpp>
#include <tensorflow/tensorflow.h>

// Function to run the trained model on new data
void runModel(const std::string& modelFile, const std::string& inputDataFile, const std::string& outputDataFile) {
    // Load trained model
    tensorflow::Session* session;
    tensorflow::Status status = tensorflow::NewSession(tensorflow::SessionOptions(), &session);
    if (status.ok()) {
        tensorflow::GraphDef graphDef;
        tensorflow::ReadBinaryProto(tensorflow::Env::Default(), modelFile, &graphDef);
        session->Create(graphDef);
        // Load input data
        cv::Mat inputData = cv::imread(inputDataFile);
        if (!inputData.empty()) {
            tensorflow::Tensor inputTensor(tensorflow::DT_FLOAT, {1, inputData.rows, inputData.cols, 3});
            tensorflow::Tensor outputTensor;
            session->Run({{"input", inputTensor}}, {"output"}, {}, &outputTensor);
            // Save output data
            std::ofstream outputData(outputDataFile);
            if (outputData.is_open()) {
                for (int i = 0; i < outputTensor.tensor_data().size(); i++) {
                    outputData << outputTensor.tensor_data()[i] << " ";
                }
                outputData.close();
            }
        }
    }
}

int main() {
    std::string modelFile = "cnn_model.pb";
    std::string inputDataFile = "new_data.jpg";
    std::string outputDataFile = "output_data.txt";
    runModel(modelFile, inputDataFile, outputDataFile);
    return 0;
}
```

**Output and Decision Making**
```cpp
// output_and_decision_making.cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <mysql/mysql.h>

// Function to output predictions and recommendations to MySQL database
void outputPredictions(const std::string& outputDataFile, const std::string& databaseHost, const std::string& databaseUser, const std::string& databasePassword, const std::string& databaseName) {
    // Connect to MySQL database
    MYSQL* conn;
    conn = mysql_init(0);
    if (conn) {
        if (mysql_real_connect(conn, databaseHost.c_str(), databaseUser.c_str(), databasePassword.c_str(), databaseName.c_str(), 0, NULL, 0)) {
            // Read output data
            std::ifstream outputData(outputDataFile);
            if (outputData.is_open()) {
                std::string line;
                while (std::getline(outputData, line)) {
                    std::vector<double> predictions;
                    std::stringstream ss(line);
                    double value;
                    while (ss >> value) {
                        predictions.push_back(value);
                    }
                    // Insert predictions into database
                    std::string query = "INSERT INTO predictions (prediction1, prediction2, prediction3) VALUES (" + std::to_string(predictions[0]) + ", " + std::to_string(predictions[1]) + ", " + std::to_string(predictions[2]) + ")";
                    mysql_query(conn, query.c_str());
                }
                outputData.close();
            }
            mysql_close(conn);
        } else {
            std::cerr << "Error connecting to database: " << mysql_error(conn) << std::endl;
        }
    } else {
        std::cerr << "Error initializing MySQL connection" << std::endl;
    }
}

// Function to control traffic lights and optimize routing based on predictions
void controlTrafficLights(const std::string& databaseHost, const std::string& databaseUser, const std::string& databasePassword, const std::string& databaseName) {
    // Connect to MySQL database
    MYSQL* conn;
    conn = mysql_init(0);
    if (conn) {
        if (mysql_real_connect(conn, databaseHost.c_str(), databaseUser.c_str(), databasePassword.c_str(), databaseName.c_str(), 0, NULL, 0)) {
            // Retrieve predictions from database
            std::string query = "SELECT * FROM predictions";
            mysql_query(conn, query.c_str());
            MYSQL_RES* res = mysql_store_result(conn);
            if (res) {
                MYSQL_ROW row;
                while ((row = mysql_fetch_row(res))) {
                    double prediction1 = std::stod(row[1]);
                    double prediction2 = std::stod(row[2]);
                    double prediction3 = std::stod(row[3]);
                    // Control traffic lights based on predictions
                    if (prediction1 > 0.5) {
                        // Turn traffic light green
                    } else if (prediction2 > 0.5) {
                        // Turn traffic light yellow
                    } else if (prediction3 > 0.5) {
                        // Turn traffic light red
                    }
                }
                mysql_free_result(res);
            }
            mysql_close(conn);
        } else {
            std::cerr << "Error connecting to database: " << mysql_error(conn) << std::endl;
        }
    } else {
        std::cerr << "Error initializing MySQL connection" << std::endl;
    }
}

int main() {
    std::string outputDataFile = "output_data.txt";
    std::string databaseHost = "localhost";
    std::string databaseUser = "root";
    std::string databasePassword = "password";
    std::string databaseName = "traffic_management";
    outputPredictions(outputDataFile, databaseHost, databaseUser, databasePassword, databaseName);
    controlTrafficLights(databaseHost, databaseUser, databasePassword, databaseName);
    return 0;
}
```

**Tests**
```cpp
// tests.cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <gtest/gtest.h>

TEST(DataPreprocessingTest, ReadData) {
    std::string sensorDataFile = "sensor_data.txt";
    std::string cameraDataFile = "camera_data.jpg";
    std::vector<std::vector<double>> data = readData(sensorDataFile, cameraDataFile);
    ASSERT_NE(data.empty(), true);
}

TEST(MachineLearningModelTest, TrainCNNModel) {
    std::string trainingDataFile = "cleaned_data.txt";
    std::string modelOutputFile = "cnn_model.pb";
    trainCNNModel(trainingDataFile, modelOutputFile);
    ASSERT_TRUE(std::ifstream(modelOutputFile).good());
}

TEST(InferenceEngineTest, RunModel) {
    std::string modelFile = "cnn_model.pb";
    std::string inputDataFile = "new_data.jpg";
    std::string outputDataFile = "output_data.txt";
    runModel(modelFile, inputDataFile, outputDataFile);
    ASSERT_TRUE(std::ifstream(outputDataFile).good());
}

TEST(OutputAndDecisionMakingTest, OutputPredictions) {
    std::string outputDataFile = "output_data.txt";
    std::string databaseHost = "localhost";
    std::string databaseUser = "root";
    std::string databasePassword = "password";
    std::string databaseName = "traffic_management";
    outputPredictions(outputDataFile, databaseHost, databaseUser, databasePassword, databaseName);
    ASSERT_TRUE(std::ifstream("predictions.txt").good());
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```